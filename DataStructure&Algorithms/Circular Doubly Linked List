#pragma once
#include <string>
#include <type_traits>
using Integer = int;
using String = std::string;

template<typename T>
struct Node {
public:
	T data;
	Node<T>* prev = nullptr;
	Node<T>* next = nullptr;
	Node(){}
	~Node(){}
	Node(T d) : data(d), prev(nullptr), next(nullptr){}
};


template<typename T>
class CDLL {
private:
	Node<T>* head = nullptr;
	Node<T>* tail = nullptr;
public:
	CDLL(){}
	~CDLL(){}
	void addAtTheBeginning(T data);
	void addAtTheEnd(T data);
	void addAtThePosition(T data, Integer pos);

	void deleteFromPosition(); // l want to use recursion here in learning goal
	void deleteAll();

	void printRecursive();
	void IsContainsValueRecursive();
private:
	void addAtThePositionRecursive(T data, Integer pos, Node<T>* ptr, Integer); // l want to use recursion here in learning goal
};

template<typename T>
void CDLL<T>::addAtTheBeginning(T data) {
	static_assert(
		std::is_same<T, int>::value ||
		std::is_same<T, double>::value ||
		std::is_same<T, String>::value,
		"Type is incorrect! Try again!!"
		);
	Node<T>* newNode = new Node<T>(data);
	if (head == nullptr) {
		head = newNode;
		tail = newNode;
		newNode->prev = newNode;
		newNode->next = newNode;
		return;
	}
	
	newNode->next = head;
	newNode->prev = tail;
	tail->next = newNode;
	head->prev = newNode;

	head = newNode;
}


template<typename T>
void CDLL<T>::addAtTheEnd(T data) {
	static_assert(
		std::is_same<T, Integer>::value ||
		std::is_same<T, double>::value ||
		std::is_same<T, String>::value,
		"The type is incorrect!"
		);
	Node<T>* newNode = new Node<T>(data);
	if (tail == nullptr) {
		head = newNode;
		tail = newNode;
		newNode->next = newNode;
		newNode->prev = newNode;
		return;
	}
	tail->next = newNode;
	newNode->prev = tail;
	newNode->next = head;
	head->prev = newNode;
	tail = newNode;
}

template<typename T>
void CDLL<T>::addAtThePosition(T data, Integer pos) {
	if (!head) {
		Node<T>* newNode = new Node<T>(data);
		head = tail = newNode;
		newNode->next = newNode;
		newNode->prev = newNode;
		return;
	}

	addAtThePositionRecursive(data, pos, head, 0);
}

template<typename T>
void CDLL<T>::addAtThePositionRecursive(T data, Integer pos, Node<T>* ptr, Integer i) {
	static_assert(
		std::is_same<T, Integer>::value ||
		std::is_same<T, double>::value ||
		std::is_same<T, String>::value,
		"The type is incorrect!"
		);

	if (ptr == head && i != 0) {
		std::cout << "Position out of bounds!\n";
		return;
	}

	if (pos == i) { // definition for ending recursion
		Node<T>* newNode = new Node<T>(data);

		if (head == ptr) { // insertion at the beginning
			newNode->next = head;
			newNode->prev = tail;
			tail->next = newNode;
			head->prev = newNode;

			head = newNode;
			return;
		}
		if (tail == ptr) { // insertion at the end
			tail->next = newNode;
			newNode->prev = tail;
			newNode->next = head;
			head->prev = newNode;
			tail = newNode;
			return;
		}

		Node<T>* prevNode = ptr->prev;

		ptr->prev = newNode;
		newNode->next = ptr;

		newNode->prev = prevNode;
		prevNode->next = newNode;
		return;
	}
	addAtThePositionRecursive(data, pos, ptr->next, i + 1);
}
